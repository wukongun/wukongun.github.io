<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wukongun.github.io</id>
    <title>wukongun</title>
    <updated>2020-05-26T02:27:46.518Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wukongun.github.io"/>
    <link rel="self" href="https://wukongun.github.io/atom.xml"/>
    <subtitle>记录点滴</subtitle>
    <logo>https://wukongun.github.io/images/avatar.png</logo>
    <icon>https://wukongun.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, wukongun</rights>
    <entry>
        <title type="html"><![CDATA[开源协议]]></title>
        <id>https://wukongun.github.io/post/kai-yuan-xie-yi/</id>
        <link href="https://wukongun.github.io/post/kai-yuan-xie-yi/">
        </link>
        <updated>2020-05-26T02:25:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="开源协议的使用-可以看下图-具体协议需要哪些约束">开源协议的使用 可以看下图 具体协议需要哪些约束</h2>
<figure data-type="image" tabindex="1"><img src="https://wukongun.github.io/post-images/1590460057155.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[weak_entry_t数据结构分析]]></title>
        <id>https://wukongun.github.io/post/weak_entry_t-shu-ju-jie-gou-fen-xi/</id>
        <link href="https://wukongun.github.io/post/weak_entry_t-shu-ju-jie-gou-fen-xi/">
        </link>
        <updated>2019-02-14T13:11:54.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-c++">struct weak_entry_t {
    DisguisedPtr&lt;objc_object&gt; referent;
    union {
        struct {
            weak_referrer_t *referrers;
            uintptr_t        out_of_line_ness : 2;
            uintptr_t        num_refs : PTR_MINUS_2;
            uintptr_t        mask;
            uintptr_t        max_hash_displacement;
        };
        struct {
            // out_of_line_ness field is low bits of inline_referrers[1]
            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];
        };
    };

    bool out_of_line() {
        return (out_of_line_ness == REFERRERS_OUT_OF_LINE);
    }

    weak_entry_t&amp; operator=(const weak_entry_t&amp; other) {
        memcpy(this, &amp;other, sizeof(other));
        return *this;
    }

    weak_entry_t(objc_object *newReferent, objc_object **newReferrer)
        : referent(newReferent)
    {
        inline_referrers[0] = newReferrer;
        for (int i = 1; i &lt; WEAK_INLINE_COUNT; i++) {
            inline_referrers[i] = nil;
        }
    }
};
</code></pre>
<p>weak_entry_t内部优化设计：<br>
一个对象对应的弱引用数目较少的话(&lt;=WEAK_INLINE_COUNT，runtime把这个值设置为4)，则其弱引用会被依次保存到一个inline数组里。这个inline数组的内存会在weak_entry_t初始化的时候一并分配好，而不是需要用到的时候再去申请新的内存空间，从而达到提到运行效率的目的。</p>
<p>此外，union中的两个struct是共享同一块内存的，如果不使用inline数组，而直接使用HashTable的方式来实现，那么num_refs，mask和max_hash_displacement这些变量都需要单独的存储空间，会使用更多的内存。综上，使用inline数组在节约一定内存空间的同时还相对提高了运行效率。</p>
<p>out_of_line_ness占用的是inline_referrers[1]最低两位的空间，也是weak_entry_t当前使用inline数组还是outline数组(也就是HashTable的实现)的标记位。</p>
<p>对weak_entry_t主要操作的函数是grow_refs_and_insert和append_referrer</p>
<p>append_referrer函数来为一个对象保存新的弱引用</p>
<pre><code class="language-c++">static void append_referrer(weak_entry_t *entry, objc_object **new_referrer)
{
    if (! entry-&gt;out_of_line()) {
        // Try to insert inline.
        for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) {
            if (entry-&gt;inline_referrers[i] == nil) {
                entry-&gt;inline_referrers[i] = new_referrer;
                return;
            }
        }

        // Couldn't insert inline. Allocate out of line.
        weak_referrer_t *new_referrers = (weak_referrer_t *)
            calloc(WEAK_INLINE_COUNT, sizeof(weak_referrer_t));
        // This constructed table is invalid, but grow_refs_and_insert
        // will fix it and rehash it.
        for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) {
            new_referrers[i] = entry-&gt;inline_referrers[i];
        }
        entry-&gt;referrers = new_referrers;
        entry-&gt;num_refs = WEAK_INLINE_COUNT;
        entry-&gt;out_of_line_ness = REFERRERS_OUT_OF_LINE;
        entry-&gt;mask = WEAK_INLINE_COUNT-1;
        entry-&gt;max_hash_displacement = 0;
    }

    assert(entry-&gt;out_of_line());

    if (entry-&gt;num_refs &gt;= TABLE_SIZE(entry) * 3/4) {
        return grow_refs_and_insert(entry, new_referrer);
    }
    size_t begin = w_hash_pointer(new_referrer) &amp; (entry-&gt;mask);
    size_t index = begin;
    size_t hash_displacement = 0;
    while (entry-&gt;referrers[index] != nil) {
        hash_displacement++;
        index = (index+1) &amp; entry-&gt;mask;
        if (index == begin) bad_weak_table(entry);
    }
    if (hash_displacement &gt; entry-&gt;max_hash_displacement) {
        entry-&gt;max_hash_displacement = hash_displacement;
    }
    weak_referrer_t &amp;ref = entry-&gt;referrers[index];
    ref = new_referrer;
    entry-&gt;num_refs++;
}
</code></pre>
<ul>
<li>
<p>append_referrer函数首先处理weak_entry_t还在使用inline数组的情况。首先尝试像inline数组中插入一个新的弱引用，如果inline数组已满，那就创建一个WEAK_INLINE_COUNT大小的新数组，改用outline的方式，将inline数组中的元素依次拷贝过来。</p>
</li>
<li>
<p>函数的后半部分处理使用outline数组的情况，如果outline数组的使用率在75%及以上，那么调用grow_refs_and_insert函数进行扩充，并且插入新的弱引用。否则就直接进行hash运算插入，过程和weak_table_t的插入过程基本相同。</p>
</li>
</ul>
<pre><code class="language-c++">__attribute__((noinline, used))
static void grow_refs_and_insert(weak_entry_t *entry, 
                                 objc_object **new_referrer)
{
    assert(entry-&gt;out_of_line());

    size_t old_size = TABLE_SIZE(entry);
    size_t new_size = old_size ? old_size * 2 : 8;

    size_t num_refs = entry-&gt;num_refs;
    weak_referrer_t *old_refs = entry-&gt;referrers;
    entry-&gt;mask = new_size - 1;
    
    entry-&gt;referrers = (weak_referrer_t *)
        calloc(TABLE_SIZE(entry), sizeof(weak_referrer_t));
    entry-&gt;num_refs = 0;
    entry-&gt;max_hash_displacement = 0;
    
    for (size_t i = 0; i &lt; old_size &amp;&amp; num_refs &gt; 0; i++) {
        if (old_refs[i] != nil) {
            append_referrer(entry, old_refs[i]);
            num_refs--;
        }
    }
    // Insert
    append_referrer(entry, new_referrer);
    if (old_refs) free(old_refs);
}
</code></pre>
<p>函数首先对outline数组进行扩充，容量是原来的两倍。而后依次将老数组中的元素hash插入到新数组中，最终hash插入新的引用。</p>
<pre><code class="language-c++">static void remove_referrer(weak_entry_t *entry, objc_object **old_referrer)
{
    if (! entry-&gt;out_of_line()) {
        for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) {
            if (entry-&gt;inline_referrers[i] == old_referrer) {
                entry-&gt;inline_referrers[i] = nil;
                return;
            }
        }
        _objc_inform(&quot;Attempted to unregister unknown __weak variable &quot;
                     &quot;at %p. This is probably incorrect use of &quot;
                     &quot;objc_storeWeak() and objc_loadWeak(). &quot;
                     &quot;Break on objc_weak_error to debug.\n&quot;, 
                     old_referrer);
        objc_weak_error();
        return;
    }

    size_t begin = w_hash_pointer(old_referrer) &amp; (entry-&gt;mask);
    size_t index = begin;
    size_t hash_displacement = 0;
    while (entry-&gt;referrers[index] != old_referrer) {
        index = (index+1) &amp; entry-&gt;mask;
        if (index == begin) bad_weak_table(entry);
        hash_displacement++;
        if (hash_displacement &gt; entry-&gt;max_hash_displacement) {
            _objc_inform(&quot;Attempted to unregister unknown __weak variable &quot;
                         &quot;at %p. This is probably incorrect use of &quot;
                         &quot;objc_storeWeak() and objc_loadWeak(). &quot;
                         &quot;Break on objc_weak_error to debug.\n&quot;, 
                         old_referrer);
            objc_weak_error();
            return;
        }
    }
    entry-&gt;referrers[index] = nil;
    entry-&gt;num_refs--;
}
</code></pre>
<ul>
<li>remove_referrer函数负责删除一个弱引用。函数首先处理inline数组的情况，直接将对应的弱引用项置空。如果使用了outline数组，则通过hash找到要删除的项，并直接删除。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[weak_table_t insert referent remove]]></title>
        <id>https://wukongun.github.io/post/weak_table_t-insert-referent-remove/</id>
        <link href="https://wukongun.github.io/post/weak_table_t-insert-referent-remove/">
        </link>
        <updated>2019-02-13T13:51:44.000Z</updated>
        <content type="html"><![CDATA[<h2 id="add-new_entry-to-the-objects-table-of-weak-references">Add new_entry to the object's table of weak references.</h2>
<pre><code class="language-c++">/** 
 * Add new_entry to the object's table of weak references.
 * Does not check whether the referent is already in the table.
 */
static void weak_entry_insert(weak_table_t *weak_table, weak_entry_t *new_entry)
{
    weak_entry_t *weak_entries = weak_table-&gt;weak_entries;
    assert(weak_entries != nil);

    size_t begin = hash_pointer(new_entry-&gt;referent) &amp; (weak_table-&gt;mask);
    size_t index = begin;
    size_t hash_displacement = 0;
    while (weak_entries[index].referent != nil) {
        //说明哈希冲突了
        index = (index+1) &amp; weak_table-&gt;mask;
        if (index == begin) bad_weak_table(weak_entries);
        hash_displacement++;
    }

    weak_entries[index] = *new_entry;
    weak_table-&gt;num_entries++;
    //不是很懂为什么要记录偏移量
    if (hash_displacement &gt; weak_table-&gt;max_hash_displacement) {
        weak_table-&gt;max_hash_displacement = hash_displacement;
    }
}
</code></pre>
<blockquote>
<p>hash_pointer是对引用(指针)的hash函数</p>
</blockquote>
<blockquote>
<p>weak_table的size保持是2的N次方，而mask的值为size - 1，所以mask的二进制后N位都是1，而之前都是0，类似于00000111。所以与mask与操作后的值肯定会在[0,mask]这个区间内，也正好是weak_table<br>
实际的合法内存空间。</p>
</blockquote>
<blockquote>
<p>如果发生了hash碰撞的话，将会依次向下寻找空位，并且用max_hash_displacement来记录整个weak_table最大的偏移量。</p>
</blockquote>
<blockquote>
<p>解决哈希冲突的方法是开放地址法</p>
</blockquote>
<p>开放地址法有个非常关键的特征，就是所有输入的元素全部存放在哈希表里，也就是说，同义词冲突的解决是不需要任何的链表来实现的(链地址法)，换句话说，也就是这个哈希表的装载因子不会超过1。它的实现是在插入一个元素的时候，先通过哈希函数进行判断，若是发生哈希冲突，就以当前地址为基准，根据再寻址的方法（探查序列），去寻找下一个地址，若发生冲突再去寻找，直至找到一个为空的地址为止。所以这种方法又称为再散列法。</p>
<h3 id="weak_table_t采用的线性探查来解决哈希冲突">weak_table_t采用的线性探查来解决哈希冲突</h3>
<h2 id="查找的过程和插入类似">查找的过程和插入类似</h2>
<pre><code class="language-c++">static weak_entry_t *
weak_entry_for_referent(weak_table_t *weak_table, objc_object *referent)
{
    assert(referent);

    weak_entry_t *weak_entries = weak_table-&gt;weak_entries;

    if (!weak_entries) return nil;

    size_t begin = hash_pointer(referent) &amp; weak_table-&gt;mask;
    size_t index = begin;
    size_t hash_displacement = 0;
    while (weak_table-&gt;weak_entries[index].referent != referent) {
        index = (index+1) &amp; weak_table-&gt;mask;
        if (index == begin) bad_weak_table(weak_table-&gt;weak_entries);
        hash_displacement++;
        if (hash_displacement &gt; weak_table-&gt;max_hash_displacement) {
            return nil;
        }
    }
    
    return &amp;weak_table-&gt;weak_entries[index];
}
</code></pre>
<h2 id="remove-entry-from-the-zones-table-of-weak-references">Remove entry from the zone's table of weak references.</h2>
<p>该函数的目的是从weak_table中删除某一项entry，即某个object和其weak引用的映射关系。函数的实现比较简单，首先将相应的内存清零，而后将weak_table的计数减一，然后调用weak_compact_maybe方法来判断是否需要缩小weak_table的空间。</p>
<pre><code class="language-c++">/**
 * Remove entry from the zone's table of weak references.
 */
static void weak_entry_remove(weak_table_t *weak_table, weak_entry_t *entry)
{
    // remove entry
    if (entry-&gt;out_of_line()) free(entry-&gt;referrers);
    bzero(entry, sizeof(*entry));

    weak_table-&gt;num_entries--;

    weak_compact_maybe(weak_table);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[苹果设备和 mac电脑闪连]]></title>
        <id>https://wukongun.github.io/post/ping-guo-she-bei-he-mac-dian-nao-shan-lian/</id>
        <link href="https://wukongun.github.io/post/ping-guo-she-bei-he-mac-dian-nao-shan-lian/">
        </link>
        <updated>2017-03-15T07:45:35.000Z</updated>
        <content type="html"><![CDATA[<h3 id="iphone连接mac充电或者调试的时候-总是闪断-总结下这个问题">iPhone连接mac充电或者调试的时候 总是闪断 总结下这个问题</h3>
<ol>
<li>首先拔插数据线 看情况有无好转 接口内是否干净 有无杂物</li>
<li>另外就是 电脑的usb电压不足 拔掉usb设备 关掉usb进程 重新连接usb设备 一般会解决闪连的问题<br>
<code>sudo killall -STOP -c usbd</code></li>
<li>如果还不行可以尝试换数据线 重复上面的方法</li>
</ol>
]]></content>
    </entry>
</feed>