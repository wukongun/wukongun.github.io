<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>weak_entry_t数据结构分析 | Andy</title>
<link rel="shortcut icon" href="https://wukongun.github.io/favicon.ico?v=1591100166159">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://wukongun.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="weak_entry_t数据结构分析 | Andy - Atom Feed" href="https://wukongun.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="struct weak_entry_t {
    DisguisedPtr&lt;objc_object&gt; referent;
    union {
        struct {
            weak_referr..." />
    <meta name="keywords" content="技术,weak,objective-c,runtime" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://wukongun.github.io">
  <img class="avatar" src="https://wukongun.github.io/images/avatar.png?v=1591100166159" alt="">
  </a>
  <h1 class="site-title">
    Andy
  </h1>
  <p class="site-description">
    
  </p>
  <div class="menu-container">
    
      
        <a href="https://wukongun.github.io" class="menu">
          首页
        </a>
      
    
      
        <a href="/tag/CUSDytWuU/" class="menu">
          技术
        </a>
      
    
      
        <a href="/tag/30I54xNlw" class="menu">
          生活
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于我
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              weak_entry_t数据结构分析
            </h2>
            <div class="post-info">
              <span>
                2019-02-14
              </span>
              <span>
                5 min read
              </span>
              
                <a href="https://wukongun.github.io/tag/CUSDytWuU/" class="post-tag">
                  # 技术
                </a>
              
                <a href="https://wukongun.github.io/tag/zBS3OuqVE/" class="post-tag">
                  # weak
                </a>
              
                <a href="https://wukongun.github.io/tag/ZXHjuSAXx/" class="post-tag">
                  # objective-c
                </a>
              
                <a href="https://wukongun.github.io/tag/QpirO_jPwY/" class="post-tag">
                  # runtime
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <pre><code class="language-c++">struct weak_entry_t {
    DisguisedPtr&lt;objc_object&gt; referent;
    union {
        struct {
            weak_referrer_t *referrers;
            uintptr_t        out_of_line_ness : 2;
            uintptr_t        num_refs : PTR_MINUS_2;
            uintptr_t        mask;
            uintptr_t        max_hash_displacement;
        };
        struct {
            // out_of_line_ness field is low bits of inline_referrers[1]
            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];
        };
    };

    bool out_of_line() {
        return (out_of_line_ness == REFERRERS_OUT_OF_LINE);
    }

    weak_entry_t&amp; operator=(const weak_entry_t&amp; other) {
        memcpy(this, &amp;other, sizeof(other));
        return *this;
    }

    weak_entry_t(objc_object *newReferent, objc_object **newReferrer)
        : referent(newReferent)
    {
        inline_referrers[0] = newReferrer;
        for (int i = 1; i &lt; WEAK_INLINE_COUNT; i++) {
            inline_referrers[i] = nil;
        }
    }
};
</code></pre>
<p>weak_entry_t内部优化设计：<br>
一个对象对应的弱引用数目较少的话(&lt;=WEAK_INLINE_COUNT，runtime把这个值设置为4)，则其弱引用会被依次保存到一个inline数组里。这个inline数组的内存会在weak_entry_t初始化的时候一并分配好，而不是需要用到的时候再去申请新的内存空间，从而达到提到运行效率的目的。</p>
<p>此外，union中的两个struct是共享同一块内存的，如果不使用inline数组，而直接使用HashTable的方式来实现，那么num_refs，mask和max_hash_displacement这些变量都需要单独的存储空间，会使用更多的内存。综上，使用inline数组在节约一定内存空间的同时还相对提高了运行效率。</p>
<p>out_of_line_ness占用的是inline_referrers[1]最低两位的空间，也是weak_entry_t当前使用inline数组还是outline数组(也就是HashTable的实现)的标记位。</p>
<p>对weak_entry_t主要操作的函数是grow_refs_and_insert和append_referrer</p>
<p>append_referrer函数来为一个对象保存新的弱引用</p>
<pre><code class="language-c++">static void append_referrer(weak_entry_t *entry, objc_object **new_referrer)
{
    if (! entry-&gt;out_of_line()) {
        // Try to insert inline.
        for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) {
            if (entry-&gt;inline_referrers[i] == nil) {
                entry-&gt;inline_referrers[i] = new_referrer;
                return;
            }
        }

        // Couldn't insert inline. Allocate out of line.
        weak_referrer_t *new_referrers = (weak_referrer_t *)
            calloc(WEAK_INLINE_COUNT, sizeof(weak_referrer_t));
        // This constructed table is invalid, but grow_refs_and_insert
        // will fix it and rehash it.
        for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) {
            new_referrers[i] = entry-&gt;inline_referrers[i];
        }
        entry-&gt;referrers = new_referrers;
        entry-&gt;num_refs = WEAK_INLINE_COUNT;
        entry-&gt;out_of_line_ness = REFERRERS_OUT_OF_LINE;
        entry-&gt;mask = WEAK_INLINE_COUNT-1;
        entry-&gt;max_hash_displacement = 0;
    }

    assert(entry-&gt;out_of_line());

    if (entry-&gt;num_refs &gt;= TABLE_SIZE(entry) * 3/4) {
        return grow_refs_and_insert(entry, new_referrer);
    }
    size_t begin = w_hash_pointer(new_referrer) &amp; (entry-&gt;mask);
    size_t index = begin;
    size_t hash_displacement = 0;
    while (entry-&gt;referrers[index] != nil) {
        hash_displacement++;
        index = (index+1) &amp; entry-&gt;mask;
        if (index == begin) bad_weak_table(entry);
    }
    if (hash_displacement &gt; entry-&gt;max_hash_displacement) {
        entry-&gt;max_hash_displacement = hash_displacement;
    }
    weak_referrer_t &amp;ref = entry-&gt;referrers[index];
    ref = new_referrer;
    entry-&gt;num_refs++;
}
</code></pre>
<ul>
<li>
<p>append_referrer函数首先处理weak_entry_t还在使用inline数组的情况。首先尝试像inline数组中插入一个新的弱引用，如果inline数组已满，那就创建一个WEAK_INLINE_COUNT大小的新数组，改用outline的方式，将inline数组中的元素依次拷贝过来。</p>
</li>
<li>
<p>函数的后半部分处理使用outline数组的情况，如果outline数组的使用率在75%及以上，那么调用grow_refs_and_insert函数进行扩充，并且插入新的弱引用。否则就直接进行hash运算插入，过程和weak_table_t的插入过程基本相同。</p>
</li>
</ul>
<pre><code class="language-c++">__attribute__((noinline, used))
static void grow_refs_and_insert(weak_entry_t *entry, 
                                 objc_object **new_referrer)
{
    assert(entry-&gt;out_of_line());

    size_t old_size = TABLE_SIZE(entry);
    size_t new_size = old_size ? old_size * 2 : 8;

    size_t num_refs = entry-&gt;num_refs;
    weak_referrer_t *old_refs = entry-&gt;referrers;
    entry-&gt;mask = new_size - 1;
    
    entry-&gt;referrers = (weak_referrer_t *)
        calloc(TABLE_SIZE(entry), sizeof(weak_referrer_t));
    entry-&gt;num_refs = 0;
    entry-&gt;max_hash_displacement = 0;
    
    for (size_t i = 0; i &lt; old_size &amp;&amp; num_refs &gt; 0; i++) {
        if (old_refs[i] != nil) {
            append_referrer(entry, old_refs[i]);
            num_refs--;
        }
    }
    // Insert
    append_referrer(entry, new_referrer);
    if (old_refs) free(old_refs);
}
</code></pre>
<p>函数首先对outline数组进行扩充，容量是原来的两倍。而后依次将老数组中的元素hash插入到新数组中，最终hash插入新的引用。</p>
<pre><code class="language-c++">static void remove_referrer(weak_entry_t *entry, objc_object **old_referrer)
{
    if (! entry-&gt;out_of_line()) {
        for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) {
            if (entry-&gt;inline_referrers[i] == old_referrer) {
                entry-&gt;inline_referrers[i] = nil;
                return;
            }
        }
        _objc_inform(&quot;Attempted to unregister unknown __weak variable &quot;
                     &quot;at %p. This is probably incorrect use of &quot;
                     &quot;objc_storeWeak() and objc_loadWeak(). &quot;
                     &quot;Break on objc_weak_error to debug.\n&quot;, 
                     old_referrer);
        objc_weak_error();
        return;
    }

    size_t begin = w_hash_pointer(old_referrer) &amp; (entry-&gt;mask);
    size_t index = begin;
    size_t hash_displacement = 0;
    while (entry-&gt;referrers[index] != old_referrer) {
        index = (index+1) &amp; entry-&gt;mask;
        if (index == begin) bad_weak_table(entry);
        hash_displacement++;
        if (hash_displacement &gt; entry-&gt;max_hash_displacement) {
            _objc_inform(&quot;Attempted to unregister unknown __weak variable &quot;
                         &quot;at %p. This is probably incorrect use of &quot;
                         &quot;objc_storeWeak() and objc_loadWeak(). &quot;
                         &quot;Break on objc_weak_error to debug.\n&quot;, 
                         old_referrer);
            objc_weak_error();
            return;
        }
    }
    entry-&gt;referrers[index] = nil;
    entry-&gt;num_refs--;
}
</code></pre>
<ul>
<li>remove_referrer函数负责删除一个弱引用。函数首先处理inline数组的情况，直接将对应的弱引用项置空。如果使用了outline数组，则通过hash找到要删除的项，并直接删除。</li>
</ul>

              </div>
              <div class="toc-container">
                
              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://wukongun.github.io/post/weak_table_t-insert-referent-remove/">
              <h3 class="post-title">
                weak_table_t insert referent remove
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  <!DOCTYPE html>
<html>
<body>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=109751&auto=1&height=32"></iframe>
<br>
Powered by <a href="https://github.com/wukongun" target="_blank">Wukongun</a>

</body>
</html>
  <a class="rss" href="https://wukongun.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
